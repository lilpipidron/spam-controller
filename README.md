Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Ход мыслей

Изначально у меня были мысли об использовании PostgreSQL, но позже, изучив больше информацию по подобным задачам, я понял, что более подходящим под условия было бы использование Redis. При реализации у нас была бы одна таблица с частыми обращениям с возможностью добавления времени нового сообщения - в подобных сценариях использования Redis быстрее, чем PostgreSQL и другие подобные решения.

За все время пользования сервисом потенциально будет накапливаться большое количество уже не актуальных сообщений, и, чтобы не отсеивать слишком большое их количество при каждом запросе, я принял решение добавить функционал удаления сообщений.

После планирования дизайна системы последовало написание кода, в ходе которого я не встретил особых проблем. Первым делом настроил СУБД, проверил работоспособность. Далее написал функционал добавления сообщений, затем создал возможнолсть получения количества, а также удаления сообщений. В завершение написал и саму реализацию функции flood control, и на этом я завершил выполнение задания.
